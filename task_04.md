# Практическое задание 4. Docker

**Цель:** ознакомится с базовыми возможностями Docker. Приобрести опыт и навыки контейнеризации приложений.

## Задания к практической работе

Каждую выполненную вами команду и результат её работы поместите в отчёт в виде скриншота. Если несколько команд и их выводы видны на одном скриншоте, в отчет можно вставить 1 скриншот на несколько команд. Команды остановки и удаления контейнеров тоже можно не помещать в отчёт.

Для данной работы можно использовать Ubuntu Server или Ubuntu Desktop по вашему выбору.

### Взаимодействие с контейнером

#### Работа с данными

Перед выполнением рекомендуется ознакомиться с [этим](https://habr.com/ru/company/ruvds/blog/441574/) постом.

По умолчанию файлы, создаваемые приложением, работающим в контейнере, сохраняются в слое контейнера, поддерживающем запись. Для того чтобы этот механизм работал, ничего специально настраивать не нужно. Приложению достаточно просто сохранить данные и продолжить заниматься своими делами. Однако после того как контейнер перестанет существовать, исчезнут и данные, сохранённые таким вот нехитрым способом.

Но не волнуйтесь, Docker позволяет работать с данными и другим образом. При помощи томов (volume) и монтирования каталогов внутрь контейнера ([bind mount](https://docs.docker.com/storage/bind-mounts/)).

![](./assets/task_04/types-of-mounts-bind.png)

1. Для начала рассмотрим монтирование каталога внутрь контейнера.

2. Создайте в домашнем каталоге пользователя папку "content" и внутри неё файл "index.html" с текстом:

    ```html
    <h1>Hello from the local directory</h1>
    ```

3. Введите команду:
    ```bash
    docker run --rm --name=web -d -p 80:80 -v ~/content:/usr/share/nginx/html nginx
    ```

    Здесь мы запускаем контейнер "nginx" с именем "web" и монтируем *локальный* каталог "content" расположенный в домашнем каталоге пользователя в каталог `/usr/share/nginx/html` расположенный в контейнере. nginx ищет в каталоге `/usr/share/nginx/html` файл "index.html" и отдаёт его по запросу на корень сайта.   
    При монтировании локального каталога в контейнер возможно несколько ситуаций:

    - Локальный каталог существует (`/dir/on/local/machine`), каталог в контейнере существует (`/dir/in/container`). Каталог "container" будет с теми же правами и с тем же содержимым, что и каталог "machine". Всё что ранее было в каталоге "container" исчезнет. Этот вариант совпадает с нашим;
    - Локальный каталог существует (`/dir/on/local/machine`), каталог в контейнере и часть указанного пути НЕ существует (`/dir/in/container`). Предположим, что в контейнере существует только каталог "/dir", тогда каталоги "in" и "container" будут созданы автоматически. При этом каталог "in" будет создан от имени и в группе "root", а конечный каталог в пути, т.е "container", как и в предыдущем случае будет с теми же правами и с тем же содержимым, что и каталог локальный каталог "machine" и наполнится его содержимым;
    - Локальный каталог и часть пути НЕ существует (`/dir/on/local/machine`), каталог в контейнере существует (`/dir/in/container`). Предположим, что на локальной машине существует только каталог "/dir", тогда каталоги "on", "local" и "machine" будут созданы автоматически. При этом каталог все они будут созданы от имени и в группе "root". Т.к. локальный каталог пустой и принадлежит "root", то и каталог "container" тоже будет пуст (даже если в нём что-то было) и будет принадлежать "root";
    - Локальный каталог и часть пути НЕ существует (`/dir/on/local/machine`), каталог в контейнере и часть пути НЕ существует (`/dir/in/container`). На обеих машинах будут созданы все недостающие каталоги от имени и в группе "root". Каталог "container" будет пуст и принадлежать естественно "root". 

    Во всех перечисленных случаях изменения внутри контейнера будут видны снаружи и наоборот. Чтобы запретить контейнеру менять файлы в каталоге в конце команды монтирования нужно указать "ro": `-v /dir/on/local/machine:/dir/in/container:ro`.

4. Откройте браузер в основной ОС и введите ip-виртуальной машины в строку адреса.
    На экране должно появиться сообщение "Hello from the local directory".

5. Измените содержимое файла "index.html" в локальной папке "content" на следующее:
    ```html
    <h1 style="color: red">Hello from the local directory</h1>
    ```

    и обновите страницу в браузере. Текст должен поменять цвет. 

6. Монтирование томов [(volumes)](https://docs.docker.com/storage/volumes/).
    Хотя монтирование каталога выглядит вполне достаточным, чтобы решить описанную ранее проблему, у него есть ряд недостатков:

    - Нужно где-то создать каталог, который будет монтироваться. Нужно самому думать где это лучше сделать.
    - Если образ содержал какие-то файлы, то при монтировании каталога они исчезнут.
    - Внутри контейнера, вы часто работаете под пользователем root и способны получить доступ к любой подмонтированной директории не обращая внимание на права доступа. Например, если случайно подмонтировать в контейнер локальную папку "/etc" то через контейнер можно будет назначить своему пользователю любые права на хостовой системе.

7. Для начала посмотрите список созданных томов:
    ```bash
    docker volume ls
    ```

    Сейчас список должен быть пуст.

8. Создайте новый том командой:
    ```
    docker volume create data
    ```

    Здесь имя тома - "data". Если не указать имя самому, то будет создан том со случайным именем.  

9. Выполните команду:
    ```bash
    docker volume inspect data
    ```

    Вы должны увидеть информацию о томе в формате json. Как видно из раздела "Mountpoint" том физически хранится у вас на диске, но о том, чтобы всё правильно монтировалось заботится уже сам docker.

10. Остановите предыдущий контейнер "web" и запустите новый, командой:

    ```bash
    docker run --rm --name=web -d -p 80:80 -v data:/usr/share/nginx/html:ro nginx
    ```

    Здесь мы создаём контейнер таким же образом как и ранее, но монтируем вместо локального каталога том "data".   
    При монтировании тома возможно несколько ситуаций:

    - Пустой том монтируется в НЕ пустой каталог (`/dir/in/container`). Том получит все файлы находящиеся в "container", а также сам том получит права доступа как у каталога.  
      В этом отношении монтирование тома отличается от монтирования локального каталога.
    - НE пустой том монтируется в НЕ пустой каталог (`/dir/in/container`). Содержимое каталога "container" заменится на содержимое тома, при этом права доступа к каталогу "container" изменятся на права доступа указанные в томе.
    - Пустой том монтируется в пустой каталог (`/dir/in/container`). Так же как и в случае с локальной папкой все не существующие каталоги будут созданы от имени и в группе "root". При этом том никак не изменится.
    - НE пустой том монтируется в пустой каталог (`/dir/in/container`). Так же как и ранее все не существующие каталоги будут созданы от имени и в группе "root", а содержимое каталога "container" заменится на содержимое тома, при этом права доступа к каталогу "container" изменятся на права доступа указанные в томе.
    - Если том с указанным именем не существовал, то он будет создан автоматически.
    - Если не указать имя тома вообще, т.е `-v /dir/in/container`, то будет создан анонимный том. Во первых его имя будет сгенерировано случайным образом, а во вторых, такой том автоматически удалится, если контейнер был запущен с опцией `--rm` (обычные тома удаляются только пользователем). 

    **Примечание:** есть одно существенное отличие тома от каталога. Если удалить из каталога все файлы, то каталог по прежнему будет помнить информацию о владельце, группе и правах доступа. Если в томе по любой причине нет файлом (даже если они были, но потом их удалили), то том не помнит никакие права доступа, а при последующем монтировании ведёт себя как абсолютно пустой том.

    Том так же как и локальный каталог можно подмонтировать в режиме только для чтения, дописав "ro" в конце, но если монтируемый том был пуст, то сначала он получит все файлы из контейнера.

11. Введите команду:
    ```bash
    docker run -d -v data:/root/site -p 6080:6080 -p 5901:5901 -e PASSWORD=123456 beneventsur/xubuntu:vscode-1.44.2
    ```

    Здесь мы запускаем контейнер из [образа](https://hub.docker.com/r/beneventsur/xubuntu) в котором установлена среда разработки Visual Studio Code и монтируем к нему тот же том, что и к предыдущему. В контейнере содержимое тома будет доступно по пути "/root/site".  
    Здесь же устанавливается переменная среды `PASSWORD` и ей присваивается значение 123456. 

12. Перейдите в браузер на основной ОС и введите в адресную строку:
    ```
    http://{ip виртуальной машины}:6080/vnc.html
    ```

    Нажмите кнопку подключение и введите пароль: 123456.  
    Перед вами должен открыть рабочий стол.

13. Откройте в браузере ещё одну страницу и введите в адресную строку ip виртуальной машины. В результате вы подключитесь к контейнеру с сервером nginx и получите от него приветственную страницу.

14. Выполните последовательность действий:

    - На первой вкладке браузера на рабочем столе найдите иконку Visual Studio Code и запустите. В ответ на ругательство о недоверии к загрузчику нажмите кнопку "Launch Anyway";
    - В открывшемся окне нажмите "File" -> "Open File...", а затем кнопку "Home" и в папке "site" выберите файл "index.html".  
      Этот файл появился в результате того, что сначала мы подключили том "data" к контейнеру с nginx и всё, что было у него в "/usr/share/nginx/html" попало в том;
    - Внесите изменения в "index.html" и сохраните его;
    - Переключитесь в браузере на вторую вкладку и обновите её.  
      Вы должны увидеть, что страница изменилась, т.е. два контейнера получают доступ к одним и тем же файлам через том "data".

15. Закройте вкладки, остановите и удалите контейнеры.
    Несмотря, на то, что контейнеры больше не существуют, файл "index.html" сохранён в томе "data".

16. Выполните команду:
    ```
    docker volume rm data
    ```

    Эта команда удалит указанный том. Когда нужно удалить все не использующиеся тома, можно воспользоваться командой: `docker volume rm prune`.

17. Кроме опции `-v` можно, для монтирования, можно воспользоваться опцией `--mount`. В этом случае нужно заменить:

    ```bash
    -v {локальный каталог или том}:{каталог в контейнере}
    --mount type={bind-для каталогов или volume-для томов},source={локальный каталог или том},target={каталог в контейнере}
    ```

18. Монтирование [`tmpfs`](https://docs.docker.com/storage/tmpfs/) (похоже на том, только в оперативной памяти, а не на диске) в данной работе рассмотрено не будет, в виду её специфичности и чтобы не усложнять работу.

##### Прямое копирование файлов

При помощи тома забрать данные из работающего контейнера не получится, т.к. тома монтируются только при создании контейнера. В этом случае забрать или отправить файлы можно при помощи команды `docker cp`.

19. Запустите новый nginx контейнер с именем "web", в фоновом режиме, без монтирования томов и пробросив наружу 80-й порт.

20. Введите команду:
    ```bash
    docker cp web:/usr/share/nginx/html/. ~/new_site
    ```

    Здесь мы копируем из контейнера "web" из каталога "/usr/share/nginx/html" все файлы в локальный каталог "\~/new_site".  
    Обратите внимание, что в конце источника файлов стоит `/.` это показывает, что нужно копировать содержимое каталога, а если эти символы убрать, то в "\~/new_site" появится сам каталог "html" с файлами.

21. Проверьте, что в "\~/new_site" появились 2 файла, затем внесите изменения в файл "index.html".

22. Введите команду:
    ```bash
    docker cp ~/new_site/. web:/usr/share/nginx/html
    ```

    Здесь всё ровно наоборот локальные файлы попадут в контейнер.

23. Проверьте, что в браузере отображается изменённая страница, а затем остановите и удалите контейнер "web".

### Сборка своего образа

До этого момента мы использовали готовые образы из репозитория DockerHub. Существует множество случаев, когда готовых образов не достаточно:

- Вас чем-то не устаревает существующий образ и вы хотите настроить его под свои потребности;
- Нужного вам инструмента нет в виде docker-образа;
- Вы хотите упаковать в контейнер своё приложение.

Рассмотрим последний вариант на примере простого Flask приложения.

#### Настройка базового Flask приложения

Сначала мы создадим простое [Flask](https://flask-docs.readthedocs.io/en/latest/quickstart/) приложение, просто для того, чтобы было что положить в Docker контейнер. Если каких-то пакетов у вас в системе не будет, просто установите их.

24. В домашнем каталоге создайте каталог `tutorial` и зайдите в него;

25. Теперь создайте каталог `flask` и зайдите в него. Тут будет flask-приложение;

26. Проверьте, что в системе установлен интерпретатор python3 и его версию:
    ```bash
    python3 --version
    ```

    В моём случае версия python 3.10.6. Эта информация нам понадобится далее.

27. Создайте виртуальное окружение с именем "ven":
    ```bash
    python3 -m venv venv
    ```

    Виртуальное окружение позволит изолировать разные проекты друг от друга и содержать в "чистоте" глобальное окружение.

28. Активируйте виртуальное окружение:
    ```bash
    source venv/bin/activate
    ```

    Если всё правильно, то в начале строки появится название виртуального окружения. Например такое: `(venv) user@user-pc:~/tutorial/flask$`;

29. Установите пакет Flask с помощью pip:

    ```bash
    pip install Flask
    ```

    `pip` - это менеджер python-пакетов, что-то вроде `apt` для ubuntu.

30. Создайте файл с именем `app.py` содержащий код из документации Flask для создания базового приложения:
     ```python
     from flask import Flask
       
     app = Flask(__name__)
       
     @app.route('/')
     def hello_world():
         return 'Hello, World!'
       
     if __name__ == "__main__":
         app.run(debug=True, host='0.0.0.0')
     ```

31. Запустите `python app.py` и вы должны увидеть запуск сервера.
     Перейдите в основную ОС и в браузере укажите ip-адрес виртуальной машины и порт 5000. Вы должны увидеть "Hello, World!");

32. Остановите приложение комбинацией клавиш: <kbd>Ctrl</kbd>+<kbd>C</kbd>;

33. Сохраните установленные пакеты (зависимости) в файл `requirements.txt`:
       ```bash
       pip freeze > requirements.txt
       ```

     Команда `freeze` выводит на экран все установленные в текущем окружении python-пакеты вместе с их версиями.  
     Если в созданном файле появится строка `pkg-resources==0.0.0` удалите её, это своего рода баг, который, в дальнейшем, не даст `pip`-у нормально устанавливать пакеты.

34. Далее можно деактивировать виртуальное окружение командой: `deactivate`. В принципе можно и не деактивировать, разницы нет. Мы будем работать с docker, а он ничего не знает о виртуальных окружениях, созданных командой `venv`.


#### Упаковка приложения в docker-контейнер

На предыдущем этапе мы написали приложение и убедились, что оно работает на хостовой системе. Теперь настало время поместить приложение в docker-контейнер.

##### Создаём Dockerfile

С базовым набором команд Dockerfile можно ознакомится в [посте на хабре](https://habr.com/ru/company/ruvds/blog/439980/), с более полной версией в [документации](https://docs.docker.com/engine/reference/builder/).

Теперь, когда у нас есть приложение, упакуем его. Как основу для нашего будущего Docker-образа будем использовать образ, с установленным интерпретатором [Python](https://hub.docker.com/_/python) (в моём случае версии 3.10.6). Версия интерпретатора важна, т.к. в файле "requirements.txt" указаны пакеты с учётом этой версии интерпретатора. 

Сначала мы напишем инструкцию (`Dockerfile`), следуя которой Docker будет собирать новый образ.

В данный момент мы всё ещё находимся в директории `flask`. Можете проверить это при помощи команды `pwd` (вы должны увидеть что-то вроде этого: `/home/user/tutorial/flask`).

35. Создайте файл с именем `Dockerfile` (`nano Dockerfile`) и скопируйте в него приведенный ниже код:
     ```dockerfile
     FROM python:3.10.6
     WORKDIR /app
     COPY / /app
     RUN pip install -r requirements.txt
     ENTRYPOINT [ "python" ]
     CMD [ "app.py" ]
     ```

     - В строке `FROM python:3.10.6` мы указываем какой базовый образ мы будем использовать для своего;
     - Командой `WORKDIR /app` мы создаем каталог с именем `app` в корне файловой системы образа и назначаем его рабочей директорией. Это как текущая папке в терминале, т.е. все команды будут выполнятся относительно неё;
     - Затем командой `COPY / /app` копируем все файлы из каталога сборки на хостовой системе (первый аргумент `/`) в каталог `/app` внутри контейнера;  
       Обратите внимание, что каталог сборки считается корнем файловой системы на хосте, т.е. где бы не находился каталог сборки такой путь:  `..` в Dockerfile-e прописать нельзя.
     - Далее мы используем команду `RUN` для запуска команды внутри контейнера. В данном случае,  для установки зависимостей, перечисленных в `requirements.txt` при помощи `pip`. Помним про `WORKDIR`;
     - Команда `ENTRYPOINT [ "python" ]` устанавливает, что при запуске контейнера (`run` или `start`) должен быть запущен исполняемый файл с аргументами в формате json-массива. В данном случае мы запускаем интерпретатор python без параметров, но могли бы например написать так: ["ls", "l", "a"];  
       Аргументы указанные при запуске контейнера после имени образа будут *добавлены* в список указанных здесь.
     - Команда `CMD [ "app.py" ]`, в данном случае, используется для того, чтобы предоставить список аргументов команде `ENTRYPOINT`. Т.е. при старте контейнера будет выполнена команда: `python app.py`.  
       Аргументы указанные при запуске контейнера после имени образа *заменят* аргументы указанные здесь.
     
     Все команды будут выполнены один раз, в процесс сборки образа, при этом каждая образует свой отдельный слой, в итоге docker-образ будет иметь структуру подобную такой:
     

![](./task_03_img/layers.png)

##### Создаём образ

Когда Dockerfile готов приступаем к созданию образа. В упрощённом смысле происходит скачивание образа виртуальной машины (c DockerHub), в которой установлена операционная система на базе Linux (может быть и Windows), а также некоторые дополнительные программы (в нашем случае Python). Затем происходит копирование на диск виртуальной машины (в каталог `/app`) содержимого текущего каталога ( в нашем случае мы находимся в `flask`) и установка зависимостей из `requirements.txt`. Получившийся образ сохраняется на локальный диск.

36. Запустим сборку образа:
     ```bash
     docker build -t flask .
     ```

     При выполнении приведенной выше команды убедитесь, что вы находитесь в каталоге `flask`, т.к. символ `.` означает, что *каталог сборки* находится в текущем каталоге. По умолчанию docker ищет файл с именем "Dockerfile" в каталоге сборки, но можно указать и другой путь (опция `--file`), при этом сама сборка будет происходить относительно каталога сборки. Т.е. где бы не находился "Dockerfile", все пути прописанные в нём будут рассчитываться исходя из расположения каталога сборки.

     Флаг `-t` с параметром `flask` означает, что у созданного образа будет имя `flask` (при желании можно добавить тег, например для указания версии образа: `flask:1.0`. Тег по умолчанию `latest`).   

37. После того, как сборка завершилась введите проверьте список образов. В нём должен появится наш образ `flask:latest`.
     Может быть, что процесс сборки будет прерван из-за ошибки, и в списке появятся ещё несколько "не доделанных" образов с именем "<none\>". В этом случае их следует удалить используя команду: `docker rmi` с указанием `IMAGE ID` удаляемого образа (возможно потребуется добавить ключ `-f`).

38. Проверьте, что приложение работает корректно (через браузер или `curl`), затем остановите его:
     ```bash
     docker run --rm -p 80:5000 flask
     ```

#####  Уменьшаем размер образа

39. Определите размер образа `flask` используя `docker image ls`.
     Святая корова, он тяжелый! Что-то около 900 МБ для python, работающего с приложением Flask? Давайте изменим это.

40. У нас есть 2 основных способа уменьшения веса образа:

     - Не копировать в образ лишних файлов;
     - Использовать более легковесный базовый образ.

41. Для начала избавимся о лишних файлов.

42. Запустите новый контейнер, а затем посмотрите что у него внутри:

     ```bash
     docker run -d --rm --name=subject flask
     docker exec subject ls
     ```

     Как видно, кроме интересующих нас файлов в контейнер попал сам Dockerfile и каталог с виртуальным окружением (он нам тоже не нужен, т.к. контейнер сам по себе виртуальное окружение). Это произошло, потому-что в мы сказали команде `COPY` копировать всё содержимое каталога сборки.  
     Обратите внимание, что команда `ls` вывела содержимое каталога "/app", а не домашнего каталога пользователя root (как происходит при обычном входе). Это произошло по тому, что в Dockerfile мы назначили этот каталог рабочим (`WORKDIR /app`), т.е. при входе в контейнер мы вначале попадаем в рабочий каталог.

43. Оценим сколько места занимают эти:
     ```bash
     docker exec subject du -ha --max-depth=1
     ```

     Здесь мы просим контейнер запустить команду `du` (disk usage) с параметром `-a` чтобы показать информацию и для файлов тоже; `-h` чтобы показать размер в читабельном виде, а не в виде байт и параметре `--max-depth=1` чтобы ограничить вывод только первым уровнем вложенности.  
     Как видно из вывода лишние файлы занимают почти 25 МБ.

44. Чтобы эти мусорные файлы не попали к образ при сборке можно поступить двумя способами:

- Во-первых, мы можем изменить `Dockerfile` и скопировать не все файлы из директории flask, а только те, которые нужны, т.е:  
  ```dockerfile
  COPY requirements.txt /app
  COPY app.py /app
  ```

  У нас очень маленькое приложение, и оно простое, но для больших проектов это может занять довольно много строк.

- 2-й вариант: Docker предоставляет нам возможность добавить файл ".dockerignore", который работает как файл ".gitignore" для git. Когда Docker запустит `COPY / /app` при создании образа он проигнорирует файлы и каталоги перечисленные в ".dockerignore" и сам ".dockerignore" тоже.

45. Создайте в каталоге `flask` файл ".dockerignore" содержащий:
     ```
     venv/
     Dockerfile
     ```

46. Пересоберите образ командой `docker build`, но назовите его `flask:clean`.
     Здесь clean - это тег. Просто, чтобы иметь возможность отличить новый образ от старого. Если тег не указать, то будет установлено значение по умолчанию latest и новый образ затрёт старый.

47. Проверьте список образов и сравните размеры `clean` и `latest`.

48. Теперь когда "мусора" в образе нет подумаем о замене базового образа для контейнера.
     В качестве базового образа мы использовали образ "python:3.10.6" построенный на ubuntu. То есть полновесная ubuntu! Чтобы просто запустить Flask-приложение!! Есть много функций ubuntu, которые нам не нужны. Возможно, нам удастся найти более легкий дистрибутив Linux для запуска нашего приложения. Один из самых популярных - `alpine`. При этом, нам даже не придётся выполнять установку интерпретатора самостоятельно, реестре python на DockerHub есть [python:3.10.6-alpine](https://hub.docker.com/layers/library/python/3.10.6-alpine/images/sha256-5b4e425e03038da758a35dc6f4473b4cf9bbadb9a7cdc2766d5d1d10ef1c9ca9?context=explore)!

49. Откройте `Dockerfile` и замените первую строку на:
     ```dockerfile
     FROM python:3.10.6-alpine
     ```

     Пересоберите образ командой `docker build` и назовите его `flask:alpine`.

50. Посмотрите список образов.
     Новый образ должен весить что-то около 60 МБ. Всё еще немного великовато, но пока на этом остановимся.

51. Удалите образы `flask` c тегами `latest`, `clean`.

52. Как упоминалось выше, если мы сейчас попробуем выполнить `docker run flask`, то получим ошибку, т.к. у нас нет образа `flask:latest` и с dockerhub его тоже скачать не получается. Следовательно, во всех командах придётся писать `flask:alpine`, что не всегда удобно. Исправим это.

53. Выполните команды:
     ```bash
     docker image tag flask:alpine flask:latest
     docker image tag flask:alpine my_app:latest
     docker image ls
     ```

     и обратите внимание на `IMAGE ID`  
     ```bash
     REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
     flask        alpine    d3b120370c04   4 minutes ago   60.5MB
     flask        latest    d3b120370c04   4 minutes ago   60.5MB
     my_app       latest    d3b120370c04   4 minutes ago   60.5MB
     ```

     Предыдущей командой мы добавили 2 других имени для образа с нашим приложением.

54. Удалите `my_app:latest` и `flask:alpine` командой `docker rmi`. При этом удалятся только имена, а сам образ останется под именем `flask:latest`.

##### Создание образа из контейнера

Обычно мы действуем по обратному сценарию, т.е. из образа создаём контейнеры, но иногда проще внести изменения в готовый контейнер и сделать из него образ, чем писать с нуля Dockerfile.

Мы будем вносить изменения в контейнер `flask`.

55. Запустите новый контейнер в фоновом режиме:

     ```bash
     docker run -d --name=flask_base flask
     ```

56. Установим в этом контейнере модуль для работы с mysql - "mysql-connector-python":
     ```bash
     docker exec flask_base pip install mysql-connector-python
     ```

57. Откройте локальный файл "app.py" и замените его содержимое [на](https://github.com/Raleigh050/task_04_app).

58. Остановите контейнер, а затем скопируйте локальный файл `app.py` в контейнер при помощи команды:
     ```bash
     docker cp app.py flask_base:/app/app.py
     ```

59. Мы изменили в контейнере всё, что хотели, теперь из него можно сделать образ (ну или просто запустить (`docker start`))
     ```bash
     docker commit flask_base var_keeper:latest
     ```

     Первый аргумент имя или id контейнера, второй аргумент имя и тег итогового образа.

60. Убедитесь, что новый образ появился в списке.

61. Теперь проверим работоспособность получившегося образа, но для этого нам понадобиться контейнер с базой данный mysql. Разумеется на DockerHub такой [есть](https://hub.docker.com/_/mysql).

62. Создайте сеть под названием "net", а затем запустите контейнер с mysql как указано на странице образа:
     ```bash
     docker run -d --name=db --network=net -v vars:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123 mysql
     ```

     Здесь мы создаём новый `mysql` контейнер с сервером БД и запускаем его в фоновом режиме; имя контейнера `db`; контейнер подключён к сети `net` (и доступен там по доменному имени `db`); кроме того, мы создаём и монтируем новый том `vars` к каталогу `/var/lib/mysql` в контейнере (чтобы хранить базу на хост машине); пароль пользователя `root` установлен в `123` через переменную среды `MYSQL_ROOT_PASSWORD`.

63. Теперь запустите контейнер из образа `var_keeper:latest`
     ```bash
     docker run -d --name=keeper --network=net -p 80:5000 var_keeper
     ```

     В коде есть отладочные принты, но контейнер в фоновом режиме не выводит информацию на экран. Чтобы её посмотреть выполните команду `docker logs keeper`.

     Если всё работает правильно, то в начале (перед выводом flask) должно быть напечатано:

     ```
     Connection to db:ОК
     Create db:ОК
     Change db:ОК
     Create table:ОК
     ```

64. Проверьте работоспособность контейнера при помощи браузера. При отправке приложению POST запроса на роут `/var/<имя переменной>` значение должно добавляться в базу данных, а при отправке GET запроса - извлекаться из базы и выводится на экран.
     Для отправки POST запроса можно ввести в строку адреса:  

     ```html
     data:text/html,<form action=http://{ip_виртуальной_машины}:80/var/a method=post><input name=value></form>
     ```

     и нажать Enter. На экране появится поле ввода. Введённое значение будет отправлено на `/var/a` и сервер запомнит новую переменную `a`.

65. Затем отправьте GET запрос (просто перейдите по `http://{ip_виртуальной_машины}/var/a`) в браузере должно появиться то значение, которое вы вводили ранее.

##### Отправляем образ на DockerHub

Перед выполнением рекомендуется посмотреть [обзорное видео по DockerHub](https://youtu.be/ERvC8RAr4YQ). Придётся проскипать рекламу, но тут наиболее полный обзор из тех, что нашёл на Youtube.

66. Зарегистрируетесь на https://hub.docker.com и зайдите под своей учёткой (возможно понадобится VPN);

67. Нажмите кнопку "Create repository" и в качестве имени укажите "var_keeper".

68. Перейдите в терминал и введите команду:
     ```bash
     docker login
     ```

     Введите имя пользователя и пароль, от DockerHub. Для того VPN пока не требуют.

69. Добавьте образу `var_keeper` ещё одно имя `<имя пользователя DockerHub>/var_keeper`. В моём случае так:
     ```bash
     docker tag var_keeper:latest raleigh050/var_keeper:latest
     ```

     Как обычно `latest` можно не указывать. Новое имя и тег могут быть любыми.

70. Отправьте образ на DockerHub командой `docker push`. В моём случае так:
     ```bash
     docker push raleigh050/var_keeper
     ```

     Теперь ваш образ доступен где угодно по имени репозитория. Т.е. его можно указывать в `Dockerfile`, `docker run`, `docker push` и т.д.  
     Например в моём случае: `docker run raleigh050/var_keeper

Полное название загруженного на DockerHub образа приведите в отчёте.

## Вопросы к практическому заданию

1. Два контейнера хотят обмениваться файлами. Каким образом можно организовать такое взаимодействие?
2. Мне нужен образ с wordpress на основе дистрибутива alpine. Приведите команду которой я могу скачать такой образ с dockerhub (версию wordpress и php выберите любую).

## Источники

1. docker-ci-cd-tutorial: https://github.com/Clemsazert/docker-ci-cd-tutorial
2. Изучаем Docker основы [все части]: https://habr.com/ru/company/ruvds/blog/438796/
3. Объяснение концепции сетей в Docker: https://itisgood.ru/2019/10/29/objasnenie-koncepcii-setej-v-docker/
4. Взаимодействие Docker контейнеров: https://dotsandbrackets.com/communication-between-docker-containers-ru/
5. Python и MySQL: практическое введение: https://proglib.io/p/python-i-mysql-prakticheskoe-vvedenie-2021-01-06
6. Docker compose - группы контейнеров: https://youtu.be/4KbL5lbjK-M
7. Обзорное видео по DockerHub: https://youtu.be/ERvC8RAr4YQ
8. Как успешно реализовать проверку состояния контейнера в Docker Compose: [длинная ссылка](https://medium.com/nuances-of-programming/как-успешно-реализовать-проверку-состояния-контейнера-в-docker-compose-6e3b449018b7)

